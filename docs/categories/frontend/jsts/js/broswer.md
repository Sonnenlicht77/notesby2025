---
layout: doc
title: chorme 浏览器
outline: deep

---
# chorme 浏览器

::: tip [前言]
在面试中，经常会被问到浏览器的渲染过程？什么是回流？什么是重绘？
什么是浏览器的事件循环？浏览器的内核有哪些？垃圾回收机制有哪些？等等。
:::




## 宏观视角下的浏览器

### Chrome: 仅打开一个页面，为什么会有四个进程？

![chrome tasks](/images/chrometasks.png)

打开浏览器的一个页面，浏览器任务管理器显示：
| 任务 | 内存占用 | CPU  | 网络 | 进程ID |
| -------- | -------- | -------- | -------- | -------- |
| 浏览器   | 160MB    | 0.5     |   0  | 582     |
| GPU进程  | 107MB     | 2.8       | 0      | 598     |
| 实用程序:NetWork Service | 33.7MB    | 0.1       | 0      | 599     |
| 实用程序:Storage Service | 18.6MB    | 0.0      | 0      | 601     |
| 实用程序: Audio Service | 17.6MB    | 0.0     | 0   | 783     |
| 备用渲染程序 | 26.4MB     |    0.0    | 0     | 15444     |
| 渲染程序 | -     | -       |   0    | 0     |

- 分析：
1. 截图中，有 7 个进程，有效进程有 6 个。
2. 浏览器进程 (PID: 582)
    - 作用: Chrome的"控制中心"
    - 负责管理用户界面、地址栏、书签、扩展管理、网络请求调度等核心功能。
    - 这是唯一有完整系统权限的进程。    
3. GPU 进程 (PID: 598)
    - 作用: 专门处理所有图形渲染任务，包括：
        - 网页的CSS动画和转换
        - 3D图形（WebGL）
        - 视频解码和渲染
        - 硬件加速的页面合成
    - 将其独立出来可以避免图形驱动问题导致整个浏览器崩溃。
4. 实用程序进程: Network Service (PID: 599)
    - 作用:  Chrome的网络栈从浏览器进程中分离出来形成的独立进程。
    - 负责：
     - 所有HTTP/HTTPS请求
     - DNS解析
     - 网络缓存
     - Cookie管理
     - 网络安全（证书验证等）
5.  实用程序进程: Storage Service (PID: 601)
    - 作用: 专门管理浏览器存储：
     - IndexedDB数据库
     - LocalStorage
     - Cache API（Service Worker缓存）
     - 文件系统访问

6.  实用程序进程: Audio Service (PID: 783)
    - 作用: 统一处理所有音频播放：
     - 网页音频API
     - HTML5音频/视频元素的音频
     - WebRTC音频流
    - 即使标签页切到后台也能保持音频播放

7.  备用渲染程序 (PID: 15444)
    - 作用:  Chrome的预启动渲染进程，用于：
    - 加速新标签页的打开速度
    - 提前初始化渲染环境
    - 当您点击新建标签页时，Chrome可以立即使用这个已准备好的进程
    - 这是Chrome性能优化的一部分



- 理论上，仅打开一个页面，至少有四个进程：
 - 浏览器进程
 - GPU 进程
 - 主渲染进程
 - 网络服务进程



### TCP协议：如何保证页面文件能被完整传输到浏览器？
::: info 
在 Web 世界中的 TCP/IP 是如何工作的?
刘超老师的《趣谈网络协议》专 栏
陶辉老师的《Web 协议详解与抓包实战》
:::


- 在衡量 Web 页面性能的时候有一个重要的指标叫“FP(First Paint)”
 - FP:First Paint 首次绘制，指从页面加载到首次开始绘制的时长。
 - 影响 FP 指标呢?
 - 其中一个重要的因素是**网络加载速度**。


####  如何保证页面文件 能被完整地送达浏览器呢?

> 数据包的视角


##### IP : 数据包如何送达主机

> IP : Internet Protocol 网际协议 ,简称 IP 协议。

数据包要在互联网上进行传输，就要符合IP标准。   
互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地。

**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**

::: tip 举例：想把一个数据包从主机 A 发送给主机 B
- 如果要想把一个数据包从主机 A 发送给主机 B，那么**在传输之前，数据包上会被附加上主机 B 的 IP 地址信息**，这样在传输过程中才能正确寻址。
- 额外地，数据包上还会**附加上主机 A 本身的 IP 地址**，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 **IP 头**的数据结构里。
- IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、 目标 IP 地址、生存时间等信息。如果你要详细了解 IP 头信息，可以参考该链接。[IP 头信息](https://en.wikipedia.org/wiki/Internet_Protocol_header)
:::

![简化三层网络传输](/images/简化三层网络传输.png)

- 一个数据包从主机 A 到主机 B 的旅程:
    - 上层将含有data数据的数据包交给网络层;
    - 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层;
    - 底层通过物理网络将数据包传输给主机 B;
    - 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层;
    - 最终，含有data信息的数据包就到达了主机 B 的上层了。



##### UDP ： 主机如何将数据包转交给应用
> UDP : User Datagram Protocol 用户数据报协议，简称 UDP 协议。



IP是网络层协议，UDP是传输层协议。  
- IP是非常底层的协议，它只负责在网络中传输数据包。
- UDP是传输层协议，它负责在应用层（如浏览器、应用程序等）和网络层之间传输数据。

UDP中最重要的是**端口号**。  
- 端口号其实就是一个数字，每个想访问网络的程序都 需要绑定一个端口号。
- 端口号是一个16位的整数，用于标识不同的应用程序或服务。
- 每个应用程序或服务都有一个唯一的端口号，用于区分不同的服务。
- 端口号分为**知名端口号**和**动态端口号**。
    - 知名端口号：0-1023，如HTTP（80）、HTTPS（443）等。
    - 动态端口号：1024-65535，用于临时通信。

通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以**IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。  

和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。  

为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示:
![四层网络传输](/images/简化四层udp层网络传输.png)

- 分析：一个数据包从主机 A 旅行到主机 B 的路线:
    - 上层将含有data数据的数据包交给**传输层**;
    - 传输层在数据包前面附加上**UDP头**，组成**新的UDP数据包**,将新的UDP数据包交给**网络层**;
    - 网络层再**将 IP 头附加到UDP数据包上**，组成**新的 IP 数据包，并交给底层**;
    - 底层通过物理网络将 IP 数据包传输给主机 B;
    - 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给**传输层**;
    - 在传输层，数据包中的 UDP 头会被拆开，并**根据 UDP 中所提供的端口号，把数据部分 交给上层的应用程序**;
    - 最终，含有data信息的数据包就到达了主机 B 的上层了。

- 🧩 **UDP 缺陷** ：
    - UDP 不能保证数据可靠性，但是传输速度却非常快
    - 如果在传输过程中发生了丢包或乱序，UDP 协议不会自动重传数据包，也不会对数据进行校验,而是直接丢弃。
    - 因此，UDP 协议通常用于对实时性要求较高的应用，如视频会议、在线游戏等。


##### TCP ：数据是如何被完整地送达应用程序 
::: warning 问题
对于浏览器请求，或者邮件这类要求数据传输可靠性(reliability)的应用，如果使用 UDP
来传输会存在两个问题:

1. 数据包在传输过程中容易丢失;
2. 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原 成完整的文件。
:::



> TCP : Transmission Control Protocol，传输控制协议。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

- **特点**
    - 对于数据包丢失的情况，**TCP 提供重传机制**;
    - TCP 引入了**数据包排序机制**，用来保证把乱序的数据包组合成一个完整的文件。
    - UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的**序列号**，以便接收端通过序号来重排数据包。

- 下面看看 TCP 下的单个数据包的传输流程:
![TCP 简化四层TCP网络传输](/images/简化四层TCP网络传输.png)

- TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。

- 完整的 TCP 连接过程:一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数 据”和“断开连接”三个阶段。
![TCP 完整连接过程](/images/一个TCP连接的生命周期.png)

- 1. **建立连接**
    - 这个阶段是通过“**三次握手**”来建立客户端和服务器之间的连接。 
    - TCP 提供面向连接的通信传输。
    - 面向连接是指在数据通信开始之前先做好两端之间的准备工作。
    - 所谓三次握手，是指**在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立**。
- 2. **传输数据**
    - 在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端 在接收到数据包之后，需要发送确认数据包给发送端。- 所以当发送端发送了一个数据包之后，在**规定时间内**没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。
    - 同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 3. **断开连接**
    - 数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。
- TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因 为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

#### 你怎么理解 HTTP 和 TCP 的关系?
HTTP 是一种基于 TCP 协议的应用层协议，它定义了客户端和服务器之间的通信规则。    

### HTTP请求流程：为什么很多站点第二次访问会更快?

HTTP 协议，建立在 TCP 连接基础之上。  

**HTTP 是一种允许浏览器向服务器获取 资源的协议，是 Web 的基础，**通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用 最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

- 此外，**HTTP 也是浏览器使用 最广的协议**，所以要想学好浏览器，就要先深入了解 HTTP。

#### 浏览器端发起 HTTP 请求流程

如果在浏览器中输入一个 URL，浏览器会根据 URL 中的协议（如 HTTP 或 HTTPS）来确定使用哪个协议来与服务器通信。

1. **构建请求**
    - 浏览器构建 **请求行**信息：
        - 请求方法（如 GET、POST 等）
        - 请求 URL
        - HTTP 版本号
    - 构建好后，浏览器发起网络请求。
2. **查找缓存** 
    - 在真正发起网络请求之前，浏览器会先检查浏览器缓存中是否有该资源的副本。
        - 浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
        - 浏览器缓存分为**内存缓存**和**磁盘缓存**。
            - 内存缓存：浏览器将最近访问过的资源存储在内存中，以便下次请求时可以直接从内存中加载。
            - 磁盘缓存：浏览器将一些静态资源（如图片、CSS 文件、JavaScript 文件等）存储在磁盘中，以便下次请求时可以直接从磁盘中加载。
    - 如果有，浏览器会直接从缓存中加载资源，而不会发起网络请求。
3. **准备IP地址和端口**  

HTTP与TCP的关系：  
- 因为浏览器 使用HTTP 协议作为应用层协议，用来封装请求的文本信息;
- 并使用TCP/IP 作传输层协议 将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。 
- 也就是说HTTP 的内容是通过 TCP 的传输数据阶段来实现的，
    - 结合下图:
    ![TCP和HTTP的关系示意图](/images/TCP和HTTP的关系示意图.png)
    - 从上图可以看出，HTTP 请求是在 TCP 连接建立之后才会发送的。
        - 这是因为 TCP 是一种面向连接的协议，所以在发送数据之前，必须先建立连接。
        - 建立TC连接，第一步就是需要 准备 IP 地址和端口号。
        - 浏览器需要知道服务器的 IP 地址和端口号，才能与服务器建立连接。
    - 数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字 标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名 (time.geekbang.org)就好记多了，所以基于这个需求又出现了一个服务，负责把域名 和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“**域名系统**”，简称
    **DNS**(Domain Name System)。
    - **浏览器需要通过 DNS 服务器将域名转换为 IP 地址，才能与服务器建立连接。**
    - 推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。  
        - 当然浏览器还提供了DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
    - 拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口 号，那么 HTTP 协议默认是 80 端口。
4. 等待TCP队列
- **已经准备好了 IP 地址和端口号，接下来就需要等待 TCP 队列了。**
- Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接， 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
- 当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。
5. 建立TCP连接
排队等待结束之后，终于可以和服务器握手了，在 HTTP 工作开始之前，浏览器通 过 TCP 与服务器建立连接。
6. 发送HTTP请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。
你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。
![HTTP请求数据格式](/images/HTTP请求数据格式.png)

- 首先浏览器会向服务器发送**请求行**，它包括了**请求方法**、**请求 URI(Uniform Resource Identifier)和 HTTP 版本协议**。
- **发送请求行**，就是告诉服务器浏览器需要什么资源，最常用的请求方法是Get。
    - 比如，直接 在浏览器地址栏键入域名(https://www.baidu.com)，这就是告诉服务器要 Get 它的首页资源。

- 另外一个常用的请求方法是**POST**，它用于发送一些数据给服务器，比如登录一个网站，就 需要通过 POST 方法把用户信息发送给服务器。
    - 如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过**请求体**来发送。
- 在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。
    - 比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求 的域名信息、浏览器端的 Cookie 信息，等等。

#### 服务器端处理 HTTP 请求流程

历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，**服务器会根据浏览器的请求信息来准备相应的内容**。

1. **返回请求**

![服务器响应的数据格式](/images/服务器响应的数据格式.png)

- 首先服务器会返回响应行，包括协议版本和状态码。
    - **协议版本**：服务器支持的 HTTP 协议版本，比如 HTTP/1.1。
    - **状态码(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status)**：服务器对请求的处理结果，比如 200 表示成功，404 表示资源不存在，500 表示服务器内部错误等等。
- 随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。 
    - 响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型 (JSON、HTML、流媒体等类型)，以及服务器要在客户端保存的 Cookie 等信息。
- **发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的 实际内容。**
2. **断开连接**

- 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
- 不过如果浏览器或者服务器在其头信息中加入了:
    - **Connection: keep-alive**
- 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接 发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。 比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连 接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。
3. **重定向**

还有一种情况你需要了解下，比如当你在浏览器中打开geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。
- 这是因为 geekbang.org 站点设置了重定向，当你访问 geekbang.org 时，服务器会返回一个状态码为 301 或 302 的响应头，告诉浏览器要跳转到 https://www.geekbang.org。
- 浏览器会自动跟随重定向，重新发送请求到 https://www.geekbang.org，最终返回 200 状态码的响应。

#### 总结

##### 1. 为什么很多站点第二次打开速度会很快?

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。  

那么，哪些数据会被缓存呢?
- 从上面介绍的核心请求路径可以发现，**DNS 缓存和页面资源缓存**这两块数据是会被浏览器缓存的。
- 其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。

![缓存查找流程示意图](/images/缓存查找流程示意图.png)

- 服务器是通过什么方式让浏览器缓存数据的?
- 从上图的第一次请求可以看出，当服务器返回HTTP 响应头给浏览器时，浏览器是通过响 应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置 一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比 如上图设置的缓存过期时间是 2000 秒。
- 这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中 的资源给浏览器。
- 但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上:
    - **If-Modified-Since** 或 **If-None-Match**
    - 这两个字段的作用是告诉服务器，**如果资源没有被修改，就返回 304 状态码，否则返回新的资源**。
    - 服务器会根据这两个字段的值，判断资源是否被修改过。如果没有被修改过，就返回 304 状态码，否则返回新的资源。
- 服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。
    - 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器:“这个缓存可以继续使 用，这次就不重复发送数据给你了。”
    - 如果资源有更新，服务器就直接返回最新资源给浏览器。
- [[浏览器缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Caching)]

- 简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

##### 2. 登录状态是如何保持的?

- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面 脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。
- 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确
    - 如果正确 的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，
        - 如下所示，然后把响应头发送给浏览器。 `Set-Cookie: UID=3431uad`

- 浏览器在接收到服务器的响应头后，开始解析响应头，
    - 如果遇到响应头里含有 Set- Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。
        - 比如把UID=3431uad保持到本地。
- 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前 保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里(如下所示)，然后浏览 器再将请求头发送给服务器。
    - `Cookie: UID=3431uad`
- 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，
    - 当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，
    - 然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
-  浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

> 浏览器的三级缓存机制

### 导航流程:从输入URL到页面展示，这中间发生了什么?

从输入 URL 到页面展示完整 流程示意图”:

![从输入 URL 到页面展示完整 流程示意图](/Volumes/web/blog/notesby2025/docs/public/images/从输入URL到页面展示完整流程示意图.png)

从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。

- 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
- 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
- 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可 以显示和交互的页面。
    - 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。
    - 这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。
- 用户发出 URL 请求到页面开始解析的这个过程，就叫做导航(navigation)。

**从输入 URL 到页面展示**

#### 1. **用户输入**  

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是**搜索内容**，还是**请求的 URL**。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。

- 当用户输入关键字并键入回车之后, 地址栏会把合成的 URL 发送给浏览器进程。
- 当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。
- 但此时页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。

#### 2. **URL请求过程**

进入了页面资源请求过程：
- 浏览器进程会通过进程间通信(IPC)把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。
- 具体流程是怎样的呢?
    - 首先，网络进程会查找本地缓存是否缓存了该资源。
        - 如果有缓存资源，那么直接返回资源给浏览器进程;
        - 如果在缓存中没有查找到资源，那么直接进入网络请求流程。
        - 这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。
            - 如果请求协议是 HTTPS，那么 还需要建立 TLS 连接。
    - 利用 IP 地址和服务器建立 TCP 连接。
        - 连接建立之后，浏览器端会构建请求行、 请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。
    - 服务器接收到请求信息后，会根据请求信息生成响应数据(包括响应行、响应头和响应体等信息)，并发给网络进程。
        - 等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。(为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。)  

 **(1) 重定向**

在接收到服务器返回的响应头后，网络进程开始解析响应头，
- 如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。
 - 这时网络进程会从响应头 的 Location 字段里面读取重定向的地址，
 - 然后再发起新的 HTTP 或者 HTTPS 请求，一切 又重头开始了。

- 服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以 继续往下处理该请求了。

- 在导航过程中，
    - 如果服务器响应行的 状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航;
    - 如果响应 行是 200，那么表示浏览器可以继续处理该请求。


**(2) 响应数据类型处理**

在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个 下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢?

- 浏览器会根据响应头的 `Content-Type` 字段来判断响应数据的类型。
    - 如果 Content-Type 是 text/html 类型，那么浏览器会把响应数据解析为 HTML 文档，然后开始渲染页面;
    - 如果 Content-Type 是 application/pdf 类型，那么浏览器会把响应数据解析为 PDF 文档，然后开始渲染页面;
    - 如果 Content-Type 是 image/png 类型，那么浏览器会把响应数据解析为 PNG 图片，然后开始渲染页面;
    - 其他类型的响应数据，浏览器会直接下载到本地。
        - 比如 application/json 类型，浏览器会把响应数据解析为 JSON 格式，然后展示在页面上;
        - 比如 text/plain 类型，浏览器会把响应数据解析为文本格式，然后展示在页面上;
        - 比如 application/xml 类型，浏览器会把响应数据解析为 XML 格式，然后展示在页面上;
        - 比如 multipart/form-data 类型，浏览器会把响应数据解析为表单数据，然后展示在页面上;
        - 比如 application/x-www-form-urlencoded 类型，浏览器会把响应数据解析为 URL 编码格式，然后展示在页面上;

- 需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是 用来展示的页面，变成了一个下载文件。

#### **3. 准备渲染进程**

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就 会配套创建一个新的渲染进程。
- 但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

- **那什么情况下多个页面会同时运行在一个渲染进程中呢?**
    - 当这些页面都属于同一个站点(域名)时，浏览器会把这些页面都运行在同一个渲染进程中。
    - 将“同一站点”定义为根域名(例如，geekbang.org)加上协议(例如，https:// 或者 http://)，还包含了该根域名下的所有子域名和不同的端口，
        - 比如下面这三个:  
            - https://time.geekbang.org/
            - https://www.geekbang.org/
            - http://geekbang.org:8080/
        - 它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。

    - Chrome 的默认策略是，每个标签对应一个渲染进程。
        - 但如果从一个页面打开了另一个新 页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。
        - 官方 把这个默认策略叫 process-per-site-instance。

- **那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢?**
    - 浏览器会为新页面创建一个新的渲染进程。
    - 这是因为不同站点之间的交互是比较危险的，为了防止一个站点的 JavaScript 代码 恶意地攻击或者窃取其他站点的信息，浏览器会为每个站点创建一个独立的渲染进程。

- 渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

#### **4. 提交文档**

首先要明确一点，这里的“文档”是指 **URL 请求的响应体数据**。  

  “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。  

   等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。 
   
   浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

#### **5. 渲染阶段**

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，  
一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会**停止标签图标上的加载动画**。  
至此，一个完整的页面就生成了。  

### 渲染流程(上):HTML、CSS和JavaScript，是如何变成页面的?

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。  
把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示:
![渲染流水线](/images/渲染流水线.png)

- 开始每个子阶段都有其输入的内容; 然后每个子阶段有其处理过程; 最终每个子阶段会生成输出内容。



#### 1. DOM树构建

![DOM树构建过程示意图](/images/DOM树构建过程示意图.png)

这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。
#### 2. 样式计算(Recalculate Style)

- 把 CSS 转换为浏览器能够理解的结构  

    和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接 收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构—— styleSheets。

- 转换样式表中的属性值，使其标准化    

    现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。

    ```css
        body { font-size: 2em } 2 p {color:blue;}
        span {display: none}
        div {font-weight: bold} 5 div p {color:green;}
        div {color:red; }
    ```
    上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过 程就是属性值标准化。

    ![标准化属性值](/images/标准化属性值.png)

- 接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢?
    - CSS 的继承规则和层叠规则
    - 每个元素的具体样式，是由其继承自祖先元素的样式，以及其自身的样式组成的。
    - 而层叠规则则是指，当一个元素有多个样式规则时，如何确定其最终的样式。

![样式的继承过程界面](/images/样式的继承过程界面.png)

- CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计 算节点样式。
- 样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了 如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式 表”正是强调了这一点

- 总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样 式，并被保存在 ComputedStyle 的结构内。

#### 3. 布局(Layout)阶段

有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不 知道 DOM 元素的几何位置信息。  

Chrome 在布局阶段需要完成两个任务:**创建布局树**和**布局计算**。

(1) **创建布局树**
    
- 布局树是指将 DOM 树中的所有可见元素都包含进来，并且每个元素都有自己的几何位置信息。
- 注意到了 DOM 树还含有很多 **不可见的元素**，比如 head 标签，还有使用了 display:none 属性的元素。
- 所以在显示之前，我们还要**额外地构建一棵只包含可见元素布局树**。

![布局树构造过程示意图](/images/布局树构造过程示意图.png)

- 从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。 
- 为了构建布局树，浏览器大体上完成了下面这些工作:
    - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中;
    - 而不可见的节点会被布局树忽略掉，
        - 如 head 标签下面的全部内容，
        - 再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，
        - 所以这个元素也没有被包进布局树。

(2) **布局计算**


有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了:  
 
布局计算是指根据布局树中的元素信息，计算出每个元素的几何位置信息。

布局的计算过程非常复杂,见【布局计算过程】


### 渲染流程(下):HTML、CSS和JavaScript，是如何变成页面的?



#### **1. 分层**

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，
并生成一棵对应的图层树(LayerTree)

**浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面**

![布局树和图层树关系示意图](/images/布局树和图层树关系示意图.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 `span` 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。


- 通常满足下面两点中任意一点的元素就可以被渲染引擎创建新的层:

    - **拥有层叠上下文属性的元素会被提升为单独的一层**
      > [Stacking_context](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Guides/Positioned_layout/Stacking_context) 
        - 根元素(HTML)
        - position 为 absolute 或 relative 且 z-index 不为 auto 的元素
        - position 为 fixed 或 sticky 的元素
        - opacity < 1
        - 以下属性值不为 none 的元素:
            - transform
            - filter
            - backdrop-filter
            - perspective
            - clip-path
            - mask / mask-image / mask-border
        - flex 容器的子元素
            - 且 z-index 不为 auto
        - grid 容器的子元素
            - 且 z-index 不为 auto
        - mix-blend-mode 不为 normal 的元素
        - isolation 为 isolate 的元素
        - contain 值为 layout、paint 或 content
        
    - **需要剪裁(clip)的地方也会被创建为图层**

#### 2. 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

渲染引擎实现图层的绘制：  
    会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

![绘制列表](/images/绘制列表.png)

从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比
如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素
的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些
待绘制列表。

#### 3. 栅格化(raster)操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的**合成线程**来完成的。
![渲染进程中的合成线程和主线程](/images/渲染进程中的合成线程和主线程.png)

如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交(commit)给合成线程，合成线程会根据绘制列表中的指令，将图层绘制到内存中。

但是，在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底
部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图
层内容的话，就会产生太大的开销，而且也没有必要。


基于这个原因，**合成线程会将图层划分为图块(tile)**，这些图块的大小通常是 256x256 或者 512x512。

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

**所谓栅格化，是指将图块转换为位图。**


图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示:
![合成线程提交图块给栅格化线程池](/images/合成线程提交图块给栅格化线程池.png)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。 

GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终 生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

![GPU栅格化](/images/GPU栅格化.png)

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块 的位图，并保存在 GPU 的内存中。

#### 4. 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程。  
浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后 根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。  
到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器 就会显示出漂亮的页面了。  

#### 5. 渲染流水线大总结

![渲染流水线大总结](/images/渲染流水线大总结.png)

结合上图，一个完整的渲染流程大致可总结为如下:  
1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的
样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程**池中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。


#### 6. 三个和渲染流水线相关的概念——“重 排”“重绘”和“合成”

理解了这三个概念对于后续 优化Web性能。  

##### 重排（Reflow）

> 重排（Reflow）是指浏览器需要更新元素的**几何位置属性**

![更新元素的几何属性](/images/更新元素的几何属性.png)

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如**改变元素的宽度、高度**等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫 重排。  

无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

##### 重绘（Repaint）

> 重绘（Repaint）是指 更新元素的绘制属性，但是不会改变元素的几何位置属性。


![更新元素背景](/images/更新元素背景.png)

通过 JavaScript 或者 CSS 修改元素的绘制属性，例如**改变元素的背景颜色**等，那么浏览器会触发重新绘制，解析之后的一系列子阶段，这个过程就叫 重绘。



从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引
起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程
就叫重绘。

**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。**


##### 合成（Compositing）
那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢?渲染引擎将跳过布局
和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。

![避开重排和重绘](/images/避开重排和重绘.png)

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段， 直接在非主线程上执行合成动画操作。  
这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

#### 问题：在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化 Web 性能吗?那又有那些具体的实践方法 能减少重绘、重排呢?
