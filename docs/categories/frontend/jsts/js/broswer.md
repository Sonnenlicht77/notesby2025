---
layout: doc
title: chorme 浏览器
outline: deep

---
# chorme 浏览器

::: tip [前言]
在面试中，经常会被问到浏览器的渲染过程？什么是回流？什么是重绘？
什么是浏览器的事件循环？浏览器的内核有哪些？垃圾回收机制有哪些？等等。
:::




## 宏观视角下的浏览器

### Chrome: 仅打开一个页面，为什么会有四个进程？

![chrome tasks](/images/chrometasks.png)

打开浏览器的一个页面，浏览器任务管理器显示：
| 任务 | 内存占用 | CPU  | 网络 | 进程ID |
| -------- | -------- | -------- | -------- | -------- |
| 浏览器   | 160MB    | 0.5     |   0  | 582     |
| GPU进程  | 107MB     | 2.8       | 0      | 598     |
| 实用程序:NetWork Service | 33.7MB    | 0.1       | 0      | 599     |
| 实用程序:Storage Service | 18.6MB    | 0.0      | 0      | 601     |
| 实用程序: Audio Service | 17.6MB    | 0.0     | 0   | 783     |
| 备用渲染程序 | 26.4MB     |    0.0    | 0     | 15444     |
| 渲染程序 | -     | -       |   0    | 0     |

- 分析：
1. 截图中，有 7 个进程，有效进程有 6 个。
2. 浏览器进程 (PID: 582)
    - 作用: Chrome的"控制中心"
    - 负责管理用户界面、地址栏、书签、扩展管理、网络请求调度等核心功能。
    - 这是唯一有完整系统权限的进程。    
3. GPU 进程 (PID: 598)
    - 作用: 专门处理所有图形渲染任务，包括：
        - 网页的CSS动画和转换
        - 3D图形（WebGL）
        - 视频解码和渲染
        - 硬件加速的页面合成
    - 将其独立出来可以避免图形驱动问题导致整个浏览器崩溃。
4. 实用程序进程: Network Service (PID: 599)
    - 作用:  Chrome的网络栈从浏览器进程中分离出来形成的独立进程。
    - 负责：
     - 所有HTTP/HTTPS请求
     - DNS解析
     - 网络缓存
     - Cookie管理
     - 网络安全（证书验证等）
5.  实用程序进程: Storage Service (PID: 601)
    - 作用: 专门管理浏览器存储：
     - IndexedDB数据库
     - LocalStorage
     - Cache API（Service Worker缓存）
     - 文件系统访问

6.  实用程序进程: Audio Service (PID: 783)
    - 作用: 统一处理所有音频播放：
     - 网页音频API
     - HTML5音频/视频元素的音频
     - WebRTC音频流
    - 即使标签页切到后台也能保持音频播放

7.  备用渲染程序 (PID: 15444)
    - 作用:  Chrome的预启动渲染进程，用于：
    - 加速新标签页的打开速度
    - 提前初始化渲染环境
    - 当您点击新建标签页时，Chrome可以立即使用这个已准备好的进程
    - 这是Chrome性能优化的一部分



- 理论上，仅打开一个页面，至少有四个进程：
 - 浏览器进程
 - GPU 进程
 - 主渲染进程
 - 网络服务进程



### TCP协议：如何保证页面文件能被完整传输到浏览器？
::: info 
在 Web 世界中的 TCP/IP 是如何工作的?
刘超老师的《趣谈网络协议》专 栏
陶辉老师的《Web 协议详解与抓包实战》
:::


- 在衡量 Web 页面性能的时候有一个重要的指标叫“FP(First Paint)”
 - FP:First Paint 首次绘制，指从页面加载到首次开始绘制的时长。
 - 影响 FP 指标呢?
 - 其中一个重要的因素是**网络加载速度**。


####  如何保证页面文件 能被完整地送达浏览器呢?

> 数据包的视角


##### IP : 数据包如何送达主机

> IP : Internet Protocol 网际协议 ,简称 IP 协议。

数据包要在互联网上进行传输，就要符合IP标准。   
互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地。

**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**

::: tip 举例：想把一个数据包从主机 A 发送给主机 B
- 如果要想把一个数据包从主机 A 发送给主机 B，那么**在传输之前，数据包上会被附加上主机 B 的 IP 地址信息**，这样在传输过程中才能正确寻址。
- 额外地，数据包上还会**附加上主机 A 本身的 IP 地址**，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 **IP 头**的数据结构里。
- IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、 目标 IP 地址、生存时间等信息。如果你要详细了解 IP 头信息，可以参考该链接。[IP 头信息](https://en.wikipedia.org/wiki/Internet_Protocol_header)
:::

![简化三层网络传输](/images/简化三层网络传输.png)

- 一个数据包从主机 A 到主机 B 的旅程:
    - 上层将含有data数据的数据包交给网络层;
    - 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层;
    - 底层通过物理网络将数据包传输给主机 B;
    - 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层;
    - 最终，含有data信息的数据包就到达了主机 B 的上层了。



##### UDP ： 主机如何将数据包转交给应用
> UDP : User Datagram Protocol 用户数据报协议，简称 UDP 协议。



IP是网络层协议，UDP是传输层协议。  
- IP是非常底层的协议，它只负责在网络中传输数据包。
- UDP是传输层协议，它负责在应用层（如浏览器、应用程序等）和网络层之间传输数据。

UDP中最重要的是**端口号**。  
- 端口号其实就是一个数字，每个想访问网络的程序都 需要绑定一个端口号。
- 端口号是一个16位的整数，用于标识不同的应用程序或服务。
- 每个应用程序或服务都有一个唯一的端口号，用于区分不同的服务。
- 端口号分为**知名端口号**和**动态端口号**。
    - 知名端口号：0-1023，如HTTP（80）、HTTPS（443）等。
    - 动态端口号：1024-65535，用于临时通信。

通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以**IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。  

和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。  

为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示:
![四层网络传输](/images/简化四层udp层网络传输.png)

- 分析：一个数据包从主机 A 旅行到主机 B 的路线:
    - 上层将含有data数据的数据包交给**传输层**;
    - 传输层在数据包前面附加上**UDP头**，组成**新的UDP数据包**,将新的UDP数据包交给**网络层**;
    - 网络层再**将 IP 头附加到UDP数据包上**，组成**新的 IP 数据包，并交给底层**;
    - 底层通过物理网络将 IP 数据包传输给主机 B;
    - 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给**传输层**;
    - 在传输层，数据包中的 UDP 头会被拆开，并**根据 UDP 中所提供的端口号，把数据部分 交给上层的应用程序**;
    - 最终，含有data信息的数据包就到达了主机 B 的上层了。

- 🧩 **UDP 缺陷** ：
    - UDP 不能保证数据可靠性，但是传输速度却非常快
    - 如果在传输过程中发生了丢包或乱序，UDP 协议不会自动重传数据包，也不会对数据进行校验,而是直接丢弃。
    - 因此，UDP 协议通常用于对实时性要求较高的应用，如视频会议、在线游戏等。


##### TCP ：数据是如何被完整地送达应用程序 
::: warning 问题
对于浏览器请求，或者邮件这类要求数据传输可靠性(reliability)的应用，如果使用 UDP
来传输会存在两个问题:

1. 数据包在传输过程中容易丢失;
2. 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原 成完整的文件。
:::



> TCP : Transmission Control Protocol，传输控制协议。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

- **特点**
    - 对于数据包丢失的情况，**TCP 提供重传机制**;
    - TCP 引入了**数据包排序机制**，用来保证把乱序的数据包组合成一个完整的文件。
    - UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的**序列号**，以便接收端通过序号来重排数据包。

- 下面看看 TCP 下的单个数据包的传输流程:
![TCP 简化四层TCP网络传输](/images/简化四层TCP网络传输.png)

- TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。

- 完整的 TCP 连接过程:一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数 据”和“断开连接”三个阶段。
![TCP 完整连接过程](/images/一个TCP连接的生命周期.png)

- 1. **建立连接**
    - 这个阶段是通过“**三次握手**”来建立客户端和服务器之间的连接。 
    - TCP 提供面向连接的通信传输。
    - 面向连接是指在数据通信开始之前先做好两端之间的准备工作。
    - 所谓三次握手，是指**在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立**。
- 2. **传输数据**
    - 在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端 在接收到数据包之后，需要发送确认数据包给发送端。- 所以当发送端发送了一个数据包之后，在**规定时间内**没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。
    - 同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 3. **断开连接**
    - 数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。
- TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因 为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

#### 你怎么理解 HTTP 和 TCP 的关系?
HTTP 是一种基于 TCP 协议的应用层协议，它定义了客户端和服务器之间的通信规则。    

### HTTP请求流程：为什么很多站点第二次访问会更快?

HTTP 协议，建立在 TCP 连接基础之上。  

**HTTP 是一种允许浏览器向服务器获取 资源的协议，是 Web 的基础，**通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用 最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

- 此外，**HTTP 也是浏览器使用 最广的协议**，所以要想学好浏览器，就要先深入了解 HTTP。

#### 浏览器端发起 HTTP 请求流程

如果在浏览器中输入一个 URL，浏览器会根据 URL 中的协议（如 HTTP 或 HTTPS）来确定使用哪个协议来与服务器通信。

1. **构建请求**
    - 浏览器构建 **请求行**信息：
        - 请求方法（如 GET、POST 等）
        - 请求 URL
        - HTTP 版本号
    - 构建好后，浏览器发起网络请求。
2. **查找缓存** 
    - 在真正发起网络请求之前，浏览器会先检查浏览器缓存中是否有该资源的副本。
        - 浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
        - 浏览器缓存分为**内存缓存**和**磁盘缓存**。
            - 内存缓存：浏览器将最近访问过的资源存储在内存中，以便下次请求时可以直接从内存中加载。
            - 磁盘缓存：浏览器将一些静态资源（如图片、CSS 文件、JavaScript 文件等）存储在磁盘中，以便下次请求时可以直接从磁盘中加载。
    - 如果有，浏览器会直接从缓存中加载资源，而不会发起网络请求。
3. **准备IP地址和端口**  

HTTP与TCP的关系：  
- 因为浏览器 使用HTTP 协议作为应用层协议，用来封装请求的文本信息;
- 并使用TCP/IP 作传输层协议 将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。 
- 也就是说HTTP 的内容是通过 TCP 的传输数据阶段来实现的，
    - 结合下图:
    ![TCP和HTTP的关系示意图](/images/TCP和HTTP的关系示意图.png)
    - 从上图可以看出，HTTP 请求是在 TCP 连接建立之后才会发送的。
        - 这是因为 TCP 是一种面向连接的协议，所以在发送数据之前，必须先建立连接。
        - 建立TC连接，第一步就是需要 准备 IP 地址和端口号。
        - 浏览器需要知道服务器的 IP 地址和端口号，才能与服务器建立连接。
    - 数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字 标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名 (time.geekbang.org)就好记多了，所以基于这个需求又出现了一个服务，负责把域名 和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“**域名系统**”，简称
    **DNS**(Domain Name System)。
    - **浏览器需要通过 DNS 服务器将域名转换为 IP 地址，才能与服务器建立连接。**
    - 推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。  
        - 当然浏览器还提供了DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
    - 拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口 号，那么 HTTP 协议默认是 80 端口。
4. 等待TCP队列
- **已经准备好了 IP 地址和端口号，接下来就需要等待 TCP 队列了。**
- Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接， 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
- 当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。
5. 建立TCP连接
排队等待结束之后，终于可以和服务器握手了，在 HTTP 工作开始之前，浏览器通 过 TCP 与服务器建立连接。
6. 发送HTTP请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。
你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。
![HTTP请求数据格式](/images/HTTP请求数据格式.png)

- 首先浏览器会向服务器发送**请求行**，它包括了**请求方法**、**请求 URI(Uniform Resource Identifier)和 HTTP 版本协议**。
- **发送请求行**，就是告诉服务器浏览器需要什么资源，最常用的请求方法是Get。
    - 比如，直接 在浏览器地址栏键入域名(https://www.baidu.com)，这就是告诉服务器要 Get 它的首页资源。

- 另外一个常用的请求方法是**POST**，它用于发送一些数据给服务器，比如登录一个网站，就 需要通过 POST 方法把用户信息发送给服务器。
    - 如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过**请求体**来发送。
- 在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。
    - 比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求 的域名信息、浏览器端的 Cookie 信息，等等。

#### 服务器端处理 HTTP 请求流程

历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，**服务器会根据浏览器的请求信息来准备相应的内容**。

1. **返回请求**

![服务器响应的数据格式](/images/服务器响应的数据格式.png)

- 首先服务器会返回响应行，包括协议版本和状态码。
    - **协议版本**：服务器支持的 HTTP 协议版本，比如 HTTP/1.1。
    - **状态码(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status)**：服务器对请求的处理结果，比如 200 表示成功，404 表示资源不存在，500 表示服务器内部错误等等。
- 随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。 
    - 响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型 (JSON、HTML、流媒体等类型)，以及服务器要在客户端保存的 Cookie 等信息。
- **发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的 实际内容。**
2. **断开连接**

- 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
- 不过如果浏览器或者服务器在其头信息中加入了:
    - **Connection: keep-alive**
- 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接 发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。 比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连 接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。
3. **重定向**

还有一种情况你需要了解下，比如当你在浏览器中打开geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。
- 这是因为 geekbang.org 站点设置了重定向，当你访问 geekbang.org 时，服务器会返回一个状态码为 301 或 302 的响应头，告诉浏览器要跳转到 https://www.geekbang.org。
- 浏览器会自动跟随重定向，重新发送请求到 https://www.geekbang.org，最终返回 200 状态码的响应。

#### 总结

##### 1. 为什么很多站点第二次打开速度会很快?

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。  

那么，哪些数据会被缓存呢?
- 从上面介绍的核心请求路径可以发现，**DNS 缓存和页面资源缓存**这两块数据是会被浏览器缓存的。
- 其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。

![缓存查找流程示意图](/images/缓存查找流程示意图.png)

- 服务器是通过什么方式让浏览器缓存数据的?
- 从上图的第一次请求可以看出，当服务器返回HTTP 响应头给浏览器时，浏览器是通过响 应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置 一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比 如上图设置的缓存过期时间是 2000 秒。
- 这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中 的资源给浏览器。
- 但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上:
    - **If-Modified-Since** 或 **If-None-Match**
    - 这两个字段的作用是告诉服务器，**如果资源没有被修改，就返回 304 状态码，否则返回新的资源**。
    - 服务器会根据这两个字段的值，判断资源是否被修改过。如果没有被修改过，就返回 304 状态码，否则返回新的资源。
- 服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。
    - 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器:“这个缓存可以继续使 用，这次就不重复发送数据给你了。”
    - 如果资源有更新，服务器就直接返回最新资源给浏览器。
- [[浏览器缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Caching)]

- 简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

##### 2. 登录状态是如何保持的?

- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面 脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。
- 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确
    - 如果正确 的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，
        - 如下所示，然后把响应头发送给浏览器。 `Set-Cookie: UID=3431uad`

- 浏览器在接收到服务器的响应头后，开始解析响应头，
    - 如果遇到响应头里含有 Set- Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。
        - 比如把UID=3431uad保持到本地。
- 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前 保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里(如下所示)，然后浏览 器再将请求头发送给服务器。
    - `Cookie: UID=3431uad`
- 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，
    - 当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，
    - 然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
-  浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

> 浏览器的三级缓存机制

### 导航流程:从输入URL到页面展示，这中间发生了什么?



